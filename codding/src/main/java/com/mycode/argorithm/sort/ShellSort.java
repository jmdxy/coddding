package com.mycode.argorithm.sort;

import org.junit.Test;

/**
 * 希尔排序(Shell Sort)是插入排序的一种。
 * 也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。该方法实质上是一种分组插入方法。
 * 希尔排序是非稳定排序算法。
 * 该方法因DL．Shell于1959年提出而得名。
 * <p/>
 * 不需要大量的辅助空间，和归并排序一样容易实现。希尔排序是基于插入排序的一种算法， 在此算法基础之上增加了一个新的特性，提高了效率。
 * 希尔排序的时间复杂度与增量序列的选取有关，希尔排序时间复杂度的下界是n*log2n。
 * 希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。但是比O(N2)
 * 复杂度的算法快得多。并且希尔排序非常容易实现，算法代码短而简单。
 * 此外，希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，与此同时快速排序在最坏的情况下执行的效率会非常差。
 * 专家们提倡，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法
 * . 本质上讲，希尔排序算法是直接插入排序算法的一种改进，减少了其复制的次数，速度要快很多。
 * <p/>
 * 快的原因：
 * 希尔排序间隔序列函数 h = h * 3+ 1
 * 希尔排序比插入排序快很多的原因：当h值很大时，数据项每一趟排序移动的元素个数少，但移动的距离很长，这是非常高效的；
 * 当h值减小时，每一趟排序移动的元素个数增加，但此时的数据项已经接近于他们最终排序后的位置。
 * <p/>
 * 直接插入排序是稳定的；而希尔排序是不稳定的。
 *
 * @author zhangxu
 */
public class ShellSort extends SortAble {

    @Test
    public void test() {
        doTest();
    }

    @Override
    public void sort(int[] array) {
        int N = array.length;

        // 3x+1 increment sequence:  1, 4, 13, 40, 121, 364, 1093, ...
        int h = 1;
        while (h < N / 3) {
            h = 3 * h + 1;
        }

        while (h >= 1) {
            // h-sort the array
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {
                    swap(j, j - h, array);
                }
            }
            h /= 3;
        }
    }
}
